spring:
  cloud:
    loadbalancer:
      ribbon:
        enabled: false # Netflix Ribbon 대신 Spring Cloud LoadBalancer 사용

    circuitbreaker:
      resilience4j:
        enabled: true  # Resilience4j 회로 차단기 활성화

        # 공통 템플릿(모든 인스턴스의 기본 값)
        configs:
          default: # 기본 회로 차단기 설정
            slidingWindowType: COUNT_BASED  # 호출 횟수 기반으로 슬라이딩 윈도우 설정 (TIME_BASED도 가능)
            slidingWindowSize: 5  # 상태 결정을 위해 고려할 최근 호출 수
            minimumNumberOfCalls: 1  # 회로 차단기가 결정을 내리기 위한 최소 호출 수
            permittedNumberOfCallsInHalfOpenState: 2  # 반개방 상태에서 허용되는 호출 수
            failureRateThreshold: 50  # 실패율이 50%를 초과하면 회로 차단 (% 기준)
            waitDurationInOpenState: 5s  # 회로가 열린 상태로 유지되는 시간 (30초)
            recordExceptions: # 실패로 간주할 예외 목록
              - java.io.RuntimeException
              - org.springframework.web.client.HttpServerErrorException

        # 서비스/클라이언트별 오버라이드
        instances:
          externalService: # 'externalService'라는 이름의 회로 차단기 인스턴스
            baseConfig: default  # 위에서 정의한 기본 설정 상속
            failureRateThreshold: 40  # 기본 설정 오버라이드: 40%로 임계값 낮춤
            waitDurationInOpenState: 20s  # 기본 설정 오버라이드: 20초로 대기 시간 단축

  # Resilience4j 개별 모듈 설정 (Retry, Bulkhead, RateLimiter)
  resilience4j:
    retry: # 재시도 설정
      configs:
        default: # 기본 재시도 설정
          maxAttempts: 3  # 최대 3회 재시도
          waitDuration: 1s  # 재시도 간 1초 대기
          enableExponentialBackoff: true  # 지수 백오프 활성화 (재시도마다 대기 시간 증가)
          exponentialBackoffMultiplier: 2.0  # 각 재시도마다 대기 시간이 2배로 증가
          retryExceptions: # 재시도할 예외 목록
            - java.io.IOException

    bulkhead: # 벌크헤드 설정 (동시 호출 제한)
      configs:
        default: # 기본 벌크헤드 설정
          type: THREADPOOL  # 스레드풀 타입 벌크헤드 사용 (SEMAPHORE 대신)
          coreThreadPoolSize: 5  # 스레드풀의 기본 스레드 수 (항상 활성 상태로 유지)
          maxThreadPoolSize: 10  # 스레드풀의 최대 스레드 수 (부하 증가 시 확장)
          queueCapacity: 50  # 모든 스레드가 사용 중일 때 대기할 수 있는 요청 수

    ratelimiter: # 속도 제한 설정
      configs:
        default: # 기본 속도 제한 설정
          limitForPeriod: 50  # 주기당 최대 50개 요청 허용
          limitRefreshPeriod: 1s  # 제한이 1초마다 초기화됨
          timeoutDuration: 0ms  # 허가 대기 시간 (0ms는 대기 없이 즉시 거부)

  rabbitmq:
    host: localhost                  # RabbitMQ 브로커의 호스트명 또는 IP. 로컬 테스트 시 'localhost' 사용.
    port: 5672                       # AMQP 포트(기본 5672). 브로커가 다른 포트를 쓰면 해당 포트로 설정.
    username: ${RABBITMQ_USERNAME}   # 연결에 사용할 사용자 계정명. 운영 환경에서는 비밀 관리 도구로 보관 권장.
    password: ${RABBITMQ_PASSWORD}   # 사용자 비밀번호. 절대 코드/레포지토리에 평문 저장 금지(환경변수/Vault 사용 권장).
#      virtual-host: /                 # 가상 호스트(VHost). 논리적 격리 단위로 여러 애플리케이션을 구분할 때 사용.
#      connection-timeout: 30000       # 연결 시 타임아웃(ms, 밀리초). 연결 수립을 기다리는 최대 시간(예: 30000 = 30초).
#      requested-heartbeat: 30         # TCP/AMQP heartbeat 간격(초). 브로커/클라이언트 양측의 연결 유지를 위함(권장 10~60초).
#      listener:
#        simple:
#          concurrency: 2              # 리스너 컨테이너의 초기 컨슈머 수(동시 리스너 수). 예: 2 -> 2개의 스레드/컨슈머.
#          max-concurrency: 10         # 동적으로 확장 가능한 최대 컨슈머 수. 스케일 아웃을 허용할 때 사용.
#          acknowledge-mode: manual    # 메시지 ACK 모드: 'manual' 또는 'auto' 또는 'none'.
#          # - manual: 코드에서 직접 ACK/NACK 처리(안정적 재처리 가능).
#          # - auto: 프레임워크가 자동으로 ACK(예외 시 재시도/재배달 동작 확인 필요).
#          # - none: 기본(없음) / 브로커 기본 동작; 보통 사용하지 않음.

feign:
  client:
    config:
      default:  # 모든 클라이언트에 적용
        connectTimeout: 5000 # 연결 시도(소켓 연결) 타임아웃: 밀리초 단위. 5000ms = 5초
        readTimeout: 5000 # 서버 응답을 기다리는 읽기 타임아웃:
        loggerLevel: full # 로거 레벨: NONE, BASIC, HEADERS, FULL 중 하나.
      user-service:  # 특정 클라이언트에만 적용
        connectTimeout: 10000
        loggerLevel: full

management:
  endpoints:
    web:
      exposure:
        include: refresh

logging:
  level:
    feign: DEBUG